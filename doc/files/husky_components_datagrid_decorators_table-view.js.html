<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>husky_components/datagrid/decorators/table-view.js - husky</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="husky"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AutoComplete.html">AutoComplete</a></li>
            
                <li><a href="../classes/AutoCompleteList.html">AutoCompleteList</a></li>
            
                <li><a href="../classes/CKEditor.html">CKEditor</a></li>
            
                <li><a href="../classes/Column-Options.html">Column-Options</a></li>
            
                <li><a href="../classes/ColumnNavigation.html">ColumnNavigation</a></li>
            
                <li><a href="../classes/DataGrid.html">DataGrid</a></li>
            
                <li><a href="../classes/Dependant Select.html">Dependant Select</a></li>
            
                <li><a href="../classes/DropdownPagination (Datagrid Decorator).html">DropdownPagination (Datagrid Decorator)</a></li>
            
                <li><a href="../classes/Dropzone.html">Dropzone</a></li>
            
                <li><a href="../classes/GroupView (Datagrid Decorator).html">GroupView (Datagrid Decorator)</a></li>
            
                <li><a href="../classes/Input.html">Input</a></li>
            
                <li><a href="../classes/Label.html">Label</a></li>
            
                <li><a href="../classes/Loader.html">Loader</a></li>
            
                <li><a href="../classes/Matcher.html">Matcher</a></li>
            
                <li><a href="../classes/Overlay.html">Overlay</a></li>
            
                <li><a href="../classes/Process.html">Process</a></li>
            
                <li><a href="../classes/Search.html">Search</a></li>
            
                <li><a href="../classes/Select.html">Select</a></li>
            
                <li><a href="../classes/SmartContent.html">SmartContent</a></li>
            
                <li><a href="../classes/TableView (Datagrid Decorator).html">TableView (Datagrid Decorator)</a></li>
            
                <li><a href="../classes/Tabs.html">Tabs</a></li>
            
                <li><a href="../classes/ThumbnailView (Datagrid Decorator).html">ThumbnailView (Datagrid Decorator)</a></li>
            
                <li><a href="../classes/Toggler.html">Toggler</a></li>
            
                <li><a href="../classes/Toolbar.html">Toolbar</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/husky_components_auto-complete.html">husky/components/auto-complete</a></li>
            
                <li><a href="../modules/husky_components_auto-complete-list.html">husky/components/auto-complete-list</a></li>
            
                <li><a href="../modules/husky_components_column-navigation.html">husky/components/column-navigation</a></li>
            
                <li><a href="../modules/husky_components_column-options.html">husky/components/column-options</a></li>
            
                <li><a href="../modules/husky_components_dropzone.html">husky/components/dropzone</a></li>
            
                <li><a href="../modules/husky_components_input.html">husky/components/input</a></li>
            
                <li><a href="../modules/husky_components_label.html">husky/components/label</a></li>
            
                <li><a href="../modules/husky_components_matcher.html">husky/components/matcher</a></li>
            
                <li><a href="../modules/husky_components_overlay.html">husky/components/overlay</a></li>
            
                <li><a href="../modules/husky_components_process.html">husky/components/process</a></li>
            
                <li><a href="../modules/husky_components_smart-content.html">husky/components/smart-content</a></li>
            
                <li><a href="../modules/husky_components_toolbar.html">husky/components/toolbar</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: husky_components/datagrid/decorators/table-view.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @class TableView (Datagrid Decorator)
 * @constructor
 *
 * @param {Object} [viewOptions] Configuration object
 * @param {Boolean} [options.editable] will not set class is-selectable to prevent hover effect for complete rows
 * @param {String} [options.className] additional classname for the wrapping div
 * @param {Boolean} [options.removeRow] displays in the last column an icon to remove a row
 * @param {Object} [options.selectItem] Configuration object of select item (column)
 * @param {Boolean} [options.selectItem.inFirstCell] If true checkbox is in the first cell. If true checkbox gets its own cell
 * @param {String} [options.selectItem.type] Type of select [checkbox, radio]
 * @param {Boolean} [options.validation] enables validation for datagrid
 * @param {Boolean} [options.validationDebug] enables validation debug for datagrid
 * @param {Boolean} [options.addRowTop] adds row to the top of the table when add row is triggered
 * @param {Boolean} [options.startTabIndex] start index for tabindex
 * @param {String} [options.columnMinWidth] sets the minimal width of table columns
 * @param {String} [options.fullWidth] If true datagrid style will be full-width mode
 * @param {Array} [options.excludeFields=[&#x27;id&#x27;]] array of fields to exclude by the view
 * @param {Boolean} [options.showHead] if TRUE head would be showed
 * @param {Array} [options.icons] array of icons to display
 * @param {String} [options.icons[].icon] the actual icon which sould be displayed
 * @param {String} [options.icons[].column] the id of the column in which the icon should be displayed
 * @param {String} [options.icons[].align] the align of the icon. &#x27;left&#x27; org &#x27;right&#x27;
 * @param {Function} [options.icons.callback] a callback to execute if the icon got clicked. Gets the id of the data-record as first argument
 * @param {Boolean} [options.hideChildrenAtBeginning] if true children get hidden, if all children are loaded at the beginning
 * @param {String|Number|Null} [options.openChildId] the id of the children to open all parents for. (only relevant in a child-list)
 * @param {String|Number|Null} [options.cssClass] css-class to give the the components element. (e.g. &quot;white-box&quot;)
 * @param {Boolean} [options.highlightSelected] highlights the clicked row when selected
 *
 * @param {Boolean} [rendered] property used by the datagrid-main class
 * @param {Function} [initialize] function which gets called once at the start of the view
 * @param {Function} [render] function to render data
 * @param {Function} [destroy] function to destroy the view and unbind events
 * @param {Function} [onResize] function which gets automatically executed on window resize
 * @param {Function} [unbindCustomEvents] function to unbind the custom events of this object
 */
define(function() {

    &#x27;use strict&#x27;;

    var defaults = {
            editable: false,
            className: &#x27;datagridcontainer&#x27;,
            fullWidth: false,
            removeRow: false,
            selectItem: {
                type: &#x27;checkbox&#x27;,      // checkbox, radio button
                inFirstCell: false
            },
            validation: false, // TODO does not work for added rows
            validationDebug: false,
            addRowTop: true,
            startTabIndex: 99999,
            excludeFields: [&#x27;&#x27;],
            cssClass: null,
            columnMinWidth: &#x27;70px&#x27;,
            thumbnailFormat: &#x27;50x50&#x27;,
            showHead: true,
            hideChildrenAtBeginning: true,
            openChildId: null,
            highlightSelected: false,
            icons: []
        },

        constants = {
            viewClass: &#x27;table-container&#x27;,
            fullWidthClass: &#x27;fullwidth&#x27;,
            // if datagrid is in fullwidth-mode (options.fullWidth is true)
            // this number gets subracted from the tables final width in the resize listener
            overflowIconSpacing: 30,
            ascClass: &#x27;fa-caret-up&#x27;,
            descClass: &#x27;fa-caret-down&#x27;,
            additionalHeaderClasses: &#x27; m-left-5 small-font&#x27;,
            rowRemoverClass: &#x27;row-remover&#x27;,
            editableClass: &#x27;editable&#x27;,
            selectAllName: &#x27;select-all&#x27;,
            isSelectedClass: &#x27;is-selected&#x27;,
            isSelectableClass: &#x27;is-selectable&#x27;,
            sortableClass: &#x27;is-sortable&#x27;,
            tableClass: &#x27;table&#x27;,
            serverValidationError: &#x27;server-validation-error&#x27;,
            oversizedClass: &#x27;oversized&#x27;,
            overflowClass: &#x27;overflow&#x27;,
            thumbSrcKey: &#x27;url&#x27;,
            thumbAltKey: &#x27;alt&#x27;,
            sortLoaderClass: &#x27;sort-loader&#x27;,
            childrenSlideDownIcon: &#x27;fa-caret-right&#x27;,
            childrenSlideUpIcon: &#x27;fa-caret-down&#x27;,
            slideDownClass: &#x27;children-toggler&#x27;,
            noChildrenClass: &#x27;no-children&#x27;,
            childrenIndentClass: &#x27;child-indent&#x27;,
            childrenLoadedClass: &#x27;children-loaded&#x27;,
            noHeadClass: &#x27;no-head&#x27;,
            selected: &#x27;selected&#x27;,
            childrenIndentPx: 25 //px
        },

        /**
         * Templates used by this class
         */
        templates = {
            removeRow: [
                &#x27;&lt;td class=&quot;remove-row&quot;&gt;&#x27;,
                    &#x27;&lt;span class=&quot;fa-trash-o pointer &#x27; + constants.rowRemoverClass + &#x27;&quot;&gt;&lt;/span&gt;&#x27;,
                &#x27;&lt;/td&gt;&#x27;
            ].join(&#x27;&#x27;),

            checkboxPlaceholder: &#x27;&lt;span class=&quot;checkbox-placeholder&quot;&gt;&lt;/span&gt;&#x27;,

            checkbox: [
                &#x27;&lt;div class=&quot;custom-checkbox&quot;&gt;&#x27;,
                &#x27;&lt;input id=&quot;&lt;%= id %&gt;&quot; type=&quot;checkbox&quot; data-form=&quot;false&quot;&lt;% if (!!checked) { %&gt; checked&lt;% } %&gt;/&gt;&#x27;,
                &#x27;&lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;&#x27;,
                &#x27;&lt;/div&gt;&#x27;
            ].join(&#x27;&#x27;),

            icon: [
                &#x27;&lt;span class=&quot;grid-icon &lt;%= align %&gt;&quot;&gt;&#x27;,
                    &#x27;&lt;span class=&quot;fa-&lt;%= icon %&gt;&quot;&gt;&lt;/span&gt;&#x27;,
                &#x27;&lt;/span&gt;&#x27;
            ].join(&#x27;&#x27;),

            checkboxCell: [
                &#x27;&lt;td class=&quot;checkbox-cell&quot;&gt;&#x27;,
                &#x27;&lt;%= checkbox %&gt;&#x27;,
                &#x27;&lt;/td&gt;&#x27;
            ].join(&#x27;&#x27;),

            radio: [
                &#x27;&lt;td&gt;&#x27;,
                &#x27;&lt;div class=&quot;custom-radio&quot;&gt;&#x27;,
                &#x27;&lt;input name=&quot;&lt;%= name %&gt;&quot; type=&quot;radio&quot;/&gt;&#x27;,
                &#x27;&lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;&#x27;,
                &#x27;&lt;/div&gt;&#x27;,
                &#x27;&lt;/td&gt;&#x27;
            ].join(&#x27;&#x27;)
        },

        /**
         * used to update the table width and its containers due to responsiveness
         * @event husky.datagrid.update.table
         */
        UPDATE_TABLE = function() {
            return this.datagrid.createEventName.call(this.datagrid, &#x27;update.table&#x27;);
        },

        /**
         * used to update the table width and its containers due to responsiveness
         * @event husky.datagrid.table.open-child
         * @param {Number|String} id The id of the data-record to open the parents for
         */
        OPEN_PARENTS = function() {
            return this.datagrid.createEventName.call(this.datagrid, &#x27;table.open-parents&#x27;);
        },

        /**
         * triggered when a radio button inside the datagrid is clicked
         * @event husky.datagrid.table.open-child
         * @param {Number|String} id The id of the data-record to open the parents for
         * @param {String} columnName column name
         */
        RADIO_SELECTED = function() {
            return this.datagrid.createEventName.call(this.datagrid, &#x27;radio.selected&#x27;);
        },

        /**
         * calculates the width of a text by creating a tablehead element and measure its width
         * @param text
         * @param classArray
         * @param isSortable
         */
        getTextWidth = function(text, classArray, isSortable) {
            var elWidth, el,
                sortIconWidth = 0,
                paddings = 20;
            // handle css classes
            if (!classArray) {
                classArray = [];
            }
            if (isSortable) {
                classArray.push(constants.sortableClass);
                sortIconWidth = 20;
            }
            classArray.push(constants.isSelectedClass);

            el = this.sandbox.dom.createElement(&#x27;&lt;table style=&quot;width:auto&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&quot;&#x27; + classArray.join(&#x27;,&#x27;) + &#x27;&quot;&gt;&#x27; + text + &#x27;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;&#x27;);
            this.sandbox.dom.css(el, {
                &#x27;position&#x27;: &#x27;absolute&#x27;,
                &#x27;visibility&#x27;: &#x27;hidden&#x27;,
                &#x27;height&#x27;: &#x27;auto&#x27;,
                &#x27;width&#x27;: &#x27;auto&#x27;
            });
            this.sandbox.dom.append(&#x27;body&#x27;, el);

            // text width + paddings and sorting icon
            elWidth = this.sandbox.dom.width(el) + paddings + sortIconWidth;

            this.sandbox.dom.remove(el);

            return elWidth;
        };

    return {

        /**
         * Initializes the view, gets called only once
         * @param {Object} context The context of the datagrid class
         * @param {Object} options The options used by the view
         */
        initialize: function(context, options) {
            // store context of the datagrid-component
            this.datagrid = context;

            // make sandbox available in this-context
            this.sandbox = this.datagrid.sandbox;

            // merge defaults with options
            this.options = this.sandbox.util.extend(true, {}, defaults, options);

            this.setVariables();
            this.bindCustomEvents();
        },

        /**
         * Method to render data in table view
         */
        render: function(data, $container) {
            var selected = null;
            this.data = data;
            this.$el = $container;

            this.$tableContainer = this.sandbox.dom.createElement(&#x27;&lt;div class=&quot;&#x27; + constants.viewClass + &#x27;&quot;/&gt;&#x27;);
            this.sandbox.dom.append(this.$el, this.$tableContainer);
            this.sandbox.dom.append(this.$tableContainer, this.prepareTable());

            // add full-width class if configured
            if (this.options.fullWidth === true) {
                this.sandbox.dom.addClass(this.$el, constants.fullWidthClass);
            }

            // add custom-css class
            if (!!this.options.cssClass) {
                this.sandbox.dom.addClass(this.$el, this.options.cssClass);
            }

            this.bindDomEvents();
            if (this.datagrid.options.resizeListeners === true) {
                this.onResize();
            }

            // initialize validation
            if (!!this.options.validation) {
                this.sandbox.form.create(this.datagrid.$el);
            }

            this.setHeaderClasses();

            // try to open all parents for a child if configured
            if (!!this.options.openChildId) {
                this.openAllParents(this.options.openChildId);
                this.options.openChildId = null;
            }
            // try to open all parents for selected records
            selected = this.datagrid.getSelectedItemIds.call(this.datagrid);
            this.sandbox.util.foreach(selected, function(recordId) {
                this.openAllParents(recordId);
            }.bind(this));

            this.rendered = true;
        },

        /**
         * Destroys the view
         */
        destroy: function() {
            this.unbindDomEvents();
            //this.sandbox.stop(this.sandbox.dom.find(&#x27;*&#x27;, this.$tableContainer));
            // remove full-width class if configured
            if (this.options.fullWidth === true) {
                this.sandbox.dom.removeClass(this.$el, constants.fullWidthClass);
            }
            // remove configured css-class
            if (!!this.options.cssClass) {
                this.sandbox.dom.removeClass(this.options.cssClass);
            }
            // remove inline-styles
            this.sandbox.dom.removeAttr(this.$el, &#x27;style&#x27;);
            this.sandbox.dom.remove(this.$tableContainer);
        },

        /**
         * Binds custom events to the datagrid related to this
         * view (like an extension)
         */
        bindCustomEvents: function() {
            // checks table widths
            this.sandbox.on(UPDATE_TABLE.call(this), this.onResize.bind(this));
            // opens all parents for a given child
            this.sandbox.on(OPEN_PARENTS.call(this), this.openAllParents.bind(this));
        },

        /**
         * Unbinds the custom-events by this view
         */
        unBindCustomEvents: function() {
            this.sandbox.off(UPDATE_TABLE.call(this));
        },

        /**
         * Unbinds the Dom-Events of the view
         */
        unbindDomEvents: function() {
            this.sandbox.dom.unbind(this.sandbox.dom.find(&#x27;*&#x27;, this.$tableContainer));
            this.sandbox.dom.unbind(this.$tableContainer);
        },

        /**
         * Binds Dom related events for this table-view
         */
        bindDomEvents: function() {
            // select events for checkboxes and radio buttons
            if (!!this.options.selectItem.type) {
                this.sandbox.dom.on(this.$tableContainer, &#x27;click&#x27;, this.selectItem.bind(this),
                    &#x27;input[type=&quot;checkbox&quot;], input[type=&quot;radio&quot;]&#x27;
                );
                //select all event
                this.sandbox.dom.on(
                    this.sandbox.dom.find(&#x27;#&#x27; + constants.selectAllName, this.$tableContainer),
                    &#x27;click&#x27;,
                    this.selectAllItems.bind(this)
                );
            }

            // events for removing row
            if (this.options.removeRow) {
                this.sandbox.dom.on(
                    this.$tableContainer, &#x27;click&#x27;, this.prepareRemoveRow.bind(this), &#x27;.&#x27; + constants.rowRemoverClass
                );
            }

            // emits an event when a table row gets clicked
            this.sandbox.dom.on(
                this.$tableContainer, &#x27;click&#x27;,
                this.emitRowClickedEvent.bind(this), &#x27;tbody tr&#x27;
            );

            // calls the icon-callback on click on an icon
            this.sandbox.dom.on(
                this.$tableContainer, &#x27;click&#x27;,
                this.callIconCallback.bind(this), &#x27;tr .grid-icon&#x27;
            );

            // calls the radio-clicked event and stops further event-propagation
            this.sandbox.dom.on(
                this.sandbox.dom.find(&#x27;.custom-radio.custom-filter&#x27;,this.$tableContainer), &#x27;click&#x27;,
                this.radioClickedCallback.bind(this)
            );

            this.sandbox.dom.on(this.$tableContainer, &#x27;click&#x27;, function(event) {
                this.sandbox.dom.stopPropagation(event);
            }.bind(this));

            // add editable events if configured
            if (!!this.options.editable) {
                this.sandbox.dom.on(
                    this.$tableContainer, &#x27;click&#x27;, this.editCellValues.bind(this), &#x27;.&#x27; + constants.editableClass
                );
                this.sandbox.dom.on(this.$tableContainer, &#x27;click&#x27;, this.focusOnRow.bind(this), &#x27;tbody tr&#x27;);

                // save on &quot;blur&quot;
                this.sandbox.dom.on(window, &#x27;click&#x27;, function() {
                    if (!!this.lastFocusedRow) {
                        this.prepareSave();
                    }
                }.bind(this));
            }

            // add sortable events if configured
            if (this.datagrid.options.sortable) {
                this.sandbox.dom.on(
                    this.sandbox.dom.find(&#x27;thead th[data-attribute]&#x27;, this.$tableContainer),
                    &#x27;click&#x27;,
                    this.prepareSort.bind(this)
                );
            }

            // add load-children events if configured
            if (!!this.datagrid.options.childrenPropertyName) {
                this.sandbox.dom.on(this.$tableContainer, &#x27;click&#x27;,
                    this.prepareChildrenLoad.bind(this), &#x27;tbody tr&#x27;
                );
            }
        },

        /**
         * Highlights clicked row and removes highlighting from the previously
         * highlighted
         * @param event
         */
        highlightRow: function(event) {
            var $row = event.currentTarget,
                $selectedRow = this.sandbox.dom.find(
                        &#x27;tbody tr.&#x27; + constants.selected,
                    this.$el
                );

            this.sandbox.dom.removeClass($selectedRow, constants.selected);
            this.sandbox.dom.addClass($row, constants.selected);
        },

        /**
         * emits radio-clicked event and stops event propagation
         */
        radioClickedCallback: function(event) {
            var parentTr = this.sandbox.dom.closest(event.currentTarget, &#x27;tr&#x27;),
                parentTd = this.sandbox.dom.closest(event.currentTarget, &#x27;td&#x27;),
                id = this.sandbox.dom.data(parentTr, &#x27;id&#x27;),
                field = this.sandbox.dom.data(parentTd, &#x27;field&#x27;);
            this.sandbox.emit(RADIO_SELECTED.call(this), id, field);
            event.stopPropagation();
        },

        /**
         * Emits the row-clicked event
         */
        emitRowClickedEvent: function(event) {
            if (!this.rowClicked) {
                this.rowClicked = true;
                var id = this.sandbox.dom.$(event.currentTarget).data(&#x27;id&#x27;);

                if (!!this.options.highlightSelected) {
                    this.highlightRow(event);
                }

                if (!!id) {
                    this.datagrid.emitItemClickedEvent.call(this.datagrid, id);
                } else {
                    this.datagrid.emitItemClickedEvent.call(this.datagrid, event);
                }

                // set row clicked back to prevent multiple emits on double click
                setTimeout(function(){
                    this.rowClicked = false;
                }.bind(this), 500);
            }
        },

        /**
         * Sets the components starting properties
         */
        setVariables: function() {
            this.rendered = false;
            this.$tableContainer = null;
            this.$table = null;
            this.$el = null;
            this.data = null;
            this.rowId = 0;
            this.rowStructure = [];
            this.errorInRow = [];
            this.bottomTabIndex = this.options.startTabIndex || 49999;
            this.topTabIndex = this.options.startTabIndex || 50000;
            this.contentMarginRight = 0;
            this.contentPaddings = 0;
            this.rowClicked = false;
        },

        /**
         * Sets the header classes used for sorting purposes
         * uses this.datagrid.sort
         */
        setHeaderClasses: function() {
            var attribute = this.datagrid.sort.attribute,
                direction = this.datagrid.sort.direction,
                $element = this.sandbox.dom.find(&#x27;thead th[data-attribute=&#x27; + attribute + &#x27;]&#x27;, this.$tableContainer),
                $span = this.sandbox.dom.children($element, &#x27;span&#x27;)[0];

            if (!!attribute) {
                this.sandbox.dom.addClass($element, constants.isSelectedClass);

                if (direction === &#x27;asc&#x27;) {
                    this.sandbox.dom.addClass($span, constants.ascClass + constants.additionalHeaderClasses);
                } else {
                    this.sandbox.dom.addClass($span, constants.descClass + constants.additionalHeaderClasses);
                }
            }
        },

        /**
         * Perapres the structure of the datagrid when element type is table
         * @returns {table} returns table element
         */
        prepareTable: function() {
            var $table, $thead, $tbody, tblClasses;

            this.$table = $table = this.sandbox.dom.createElement(&#x27;&lt;table&#x27; + (!!this.options.validationDebug ? &#x27;data-debug=&quot;true&quot;&#x27; : &#x27;&#x27; ) + &#x27;/&gt;&#x27;);

            if (!!this.data.head || !!this.datagrid.matchings) {
                $thead = this.sandbox.dom.createElement(&#x27;&lt;thead/&gt;&#x27;);
                this.sandbox.dom.append($thead, this.prepareTableHead());
                this.sandbox.dom.append($table, $thead);
            }

            if (this.options.showHead === false) {
                this.sandbox.dom.addClass(this.$tableContainer, constants.noHeadClass);
            }

            if (!!this.data.embedded) {
                $tbody = this.sandbox.dom.createElement(&#x27;&lt;tbody/&gt;&#x27;);
                this.prepareTableRows($tbody);
                this.sandbox.dom.append($table, $tbody);
            }

            // set html classes
            tblClasses = [];
            tblClasses.push(
                (!!this.options.className &amp;&amp; this.options.className !== constants.tableClass) ? constants.tableClass +
                    &#x27; &#x27; + this.options.className : constants.tableClass
            );

            // when list should not have the hover effect for whole rows do not set the is-selectable class
            if (!this.options.editable) {
                tblClasses.push((this.options.selectItem &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) ? constants.isSelectableClass : &#x27;&#x27;);
            }

            this.sandbox.dom.addClass($table, tblClasses.join(&#x27; &#x27;));

            return $table;
        },

        /**
         * Prepares table head
         * @returns {string} returns table head
         */

        prepareTableHead: function() {
            var tblColumns, tblCellClass, headData, widthValues, dataAttribute,
                tblColumnStyle, minWidth, count = 0;

            tblColumns = [];
            headData = this.datagrid.matchings || this.data.head;

            // add a checkbox to head row
            if (!!this.options.selectItem &amp;&amp; !!this.options.selectItem.type) {
                tblColumns.push(
                        &#x27;&lt;th class=&quot;&#x27; + constants.selectAllName + &#x27; checkbox-cell&quot;&gt;&#x27;
                );

                if (this.options.selectItem.type === &#x27;checkbox&#x27;) {
                    tblColumns.push(this.sandbox.util.template(templates.checkbox)({
                        id: constants.selectAllName,
                        checked: false
                    }));
                }

                tblColumns.push(&#x27;&lt;/th&gt;&#x27;);
            }

            this.rowStructure = [];

            // value used for correct tabindex when row added at top of table
            this.tabIndexParam = 1;

            this.sandbox.util.foreach(headData, function(column) {
                if (this.options.excludeFields.indexOf(column.attribute) &lt; 0) {

                    // calculate width
                    tblColumnStyle = [];
                    tblCellClass = &#x27;&#x27;;
                    if (column.width) {
                        minWidth = column.width;
                    } else if (column.minWidth) {
                        minWidth = column.minWidth;
                    } else {
                        minWidth = getTextWidth.call(this, column.content, [], column.sortable);
                        minWidth = (minWidth &gt; this.datagrid.getNumberAndUnit(this.options.columnMinWidth).number) ? minWidth + &#x27;px&#x27; : this.options.columnMinWidth;

                    }
                    tblColumnStyle.push(&#x27;min-width:&#x27; + minWidth);
                    column.minWidth = minWidth;

                    // get width and measureunit
                    if (!!column.width) {
                        widthValues = this.datagrid.getNumberAndUnit(column.width);
                        tblColumnStyle.push(&#x27;max-width:&#x27; + widthValues.number + widthValues.unit);
                        tblColumnStyle.push(&#x27;width:&#x27; + widthValues.number + widthValues.unit);
                    }

                    // add to row structure when valid entry
                    if (column.attribute !== undefined) {
                        this.rowStructure.push({
                            attribute: column.attribute,
                            editable: column.editable,
                            validation: column.validation,
                            type: column.type
                        });

                        if (!!column.editable) {
                            this.tabIndexParam++;
                        }
                    }

                    // add children-toggler class if children toggle is enabled
                    if (!!this.datagrid.options.childrenPropertyName &amp;&amp; count === 0) {
                        tblCellClass = constants.slideDownClass;
                    }

                    // add html to table header cell if sortable
                    if (!!column.sortable) {
                        dataAttribute = &#x27; data-attribute=&quot;&#x27; + column.attribute + &#x27;&quot;&#x27;;
                        tblCellClass += ((!!column.class) ? &#x27; &#x27; + column.class + &#x27; &#x27; + constants.sortableClass : &#x27; &#x27; + constants.sortableClass + &#x27;&#x27;);
                        tblColumns.push(&#x27;&lt;th class=&quot;&#x27; + tblCellClass + &#x27;&quot; style=&quot;&#x27; + tblColumnStyle.join(&#x27;;&#x27;) + &#x27;&quot; &#x27; + dataAttribute + &#x27;&gt;&#x27; + column.content + &#x27;&lt;span&gt;&lt;/span&gt;&lt;/th&gt;&#x27;);
                    } else {
                        tblCellClass += ((!!column.class) ? &#x27; &#x27; + column.class + &#x27;&#x27; : &#x27;&#x27;);
                        tblColumns.push(&#x27;&lt;th class=&quot;&#x27; + tblCellClass + &#x27;&quot; style=&quot;&#x27; + tblColumnStyle.join(&#x27;;&#x27;) + &#x27;&quot; &gt;&#x27; + column.content + &#x27;&lt;/th&gt;&#x27;);
                    }
                }
                count++;
            }.bind(this));

            // remove-row entry
            if (!!this.options.removeRow) {
                tblColumns.push(&#x27;&lt;th style=&quot;width:30px;&quot;/&gt;&#x27;);
            }

            return &#x27;&lt;tr&gt;&#x27; + tblColumns.join(&#x27;&#x27;) + &#x27;&lt;/tr&gt;&#x27;;
        },

        /**
         * Itterates over all items and prepares the rows
         * @param {Object} container to insert the table-rows the table-rows to
         */
        prepareTableRows: function($container) {
            var $row, $parent;

            if (!!this.data.embedded) {
                this.data.embedded.forEach(function(row) {
                    $parent = null;
                    $row = this.prepareTableRow(row, false);
                    if (!!row.parent) {
                        $parent = this.sandbox.dom.find(&#x27;tr[data-id=&quot;&#x27; + row.parent + &#x27;&quot;]&#x27;, $container);
                    }
                    if (!!$parent) {
                        this.insertChild($row, $parent, row.parent, this.options.hideChildrenAtBeginning);
                    } else {
                        this.sandbox.dom.append($container, $row);
                    }
                }.bind(this));
            }
        },

        /**
         * Responsible for creating a single table-row
         * @param row {Object} the data for a row
         * @param triggeredByAddRow
         * @returns {*}
         */
        prepareTableRow: function(row, triggeredByAddRow) {
            var $tableRow, radioPrefix, key, i;

            if (!!(this.options.template &amp;&amp; this.options.template.row)) {
                $tableRow = this.sandbox.template.parse(this.options.template.row, row);

            } else {
                this.tblColumns = [];
                this.tblRowAttributes = &#x27; data-dom-id=&quot;dom-&#x27; + this.datagrid.options.instanceName + &#x27;-&#x27; + this.rowId + &#x27;&quot;&#x27;;
                this.rowId++;

                if (!!this.options.className &amp;&amp; this.options.className !== &#x27;&#x27;) {
                    radioPrefix = &#x27;-&#x27; + this.options.className;
                } else {
                    radioPrefix = &#x27;&#x27;;
                }

                // if the select-item should have its own cell add a checkbox or a radio-button
                if (this.options.selectItem.inFirstCell !== true) {
                    // and don&#x27;t display the checkbox anyway if only leaves should have a checkbox and record has children
                    if (!(this.datagrid.options.onlySelectLeaves === true &amp;&amp; row[this.datagrid.options.childrenPropertyName] &gt; 0)) {
                        // add a checkbox-cell to each row
                        if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) {
                            this.tblColumns.push(this.sandbox.util.template(templates.checkboxCell)({
                                checkbox: this.sandbox.util.template(templates.checkbox)({
                                    id: &#x27;&#x27;,
                                    checked: !!row.selected
                                })
                            }));

                            // add a radio to each row
                        } else if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;radio&#x27;) {
                            this.tblColumns.push(this.sandbox.util.template(templates.radio)({
                                name: &#x27;husky-radio&#x27; + radioPrefix
                            }));
                        }
                    } else {
                        this.tblColumns.push(&#x27;&lt;td&gt;&lt;/td&gt;&#x27;);
                    }
                }

                // when row structure contains more elements than the id then use the structure to set values
                if (this.rowStructure.length) {

                    if (!!triggeredByAddRow &amp;&amp; !!this.options.addRowTop) {
                        this.bottomTabIndex -= (this.tabIndexParam + 1);
                    }

                    this.sandbox.util.foreach(this.rowStructure, function(key, index) {
                        key.editable = key.editable || false;
                        this.createRowCell(key.attribute, row[key.attribute], key.type, key.editable, key.validation, triggeredByAddRow, index, row);
                    }.bind(this));

                } else {
                    i = 0;
                    for (key in row) {
                        if (row.hasOwnProperty(key)) {
                            this.createRowCell(key, row[key], null, false, null, triggeredByAddRow, i, row);
                            i++;
                        }
                    }
                }

                if (!!this.options.removeRow) {
                    this.tblColumns.push(this.sandbox.util.template(templates.removeRow)());
                }

                $tableRow = this.sandbox.dom.createElement(&#x27;&lt;tr&#x27; + this.tblRowAttributes + &#x27;&gt;&#x27; + this.tblColumns.join(&#x27;&#x27;) + &#x27;&lt;/tr&gt;&#x27;);

                if (!!row.id) {
                    this.sandbox.dom.data($tableRow, &#x27;id&#x27;, row.id);
                    this.sandbox.dom.attr($tableRow, &#x27;data-id&#x27;, row.id);
                }
            }
            return $tableRow;
        },

        /**
         * Sets the value of row cell and the data-id attribute for the row
         * @param key attribute name
         * @param value attribute value
         * @param type {String} The type of the cell. Used to call a function to manipulate the content
         * @param editable flag whether field is editable or not
         * @param validation information for field
         * @param triggeredByAddRow triggered trough add row
         * @param index
         * @param row {Object} the row object
         */
        createRowCell: function (key, value, type, editable, validation, triggeredByAddRow, index, row) {
            var tblCellClasses,
                tblCellContent,
                tblCellStyle,
                tblCellClass,
                k,
                validationAttr = &#x27;&#x27;,
                $cell,
                $innerContainer;

            if (!value) {
                value = &#x27;&#x27;;
            }

            if (this.options.excludeFields.indexOf(key) &lt; 0) {
                tblCellClasses = [];
                tblCellContent = value;

                // prepare table cell classes
                !!value.class &amp;&amp; tblCellClasses.push(value.class);
                (type === this.datagrid.types.THUMBNAILS) &amp;&amp; tblCellClasses.push(&#x27;thumb&#x27;);

                tblCellClass = (!!tblCellClasses.length) ? &#x27;class=&quot;&#x27; + tblCellClasses.join(&#x27; &#x27;) + &#x27;&quot;&#x27; : &#x27;&#x27;;

                if (!!this.options.validation &amp;&amp; !!validation) {
                    for (k in validation) {
                        validationAttr += [&#x27;data-validation-&#x27;, k, &#x27;=&quot;&#x27;, validation[k], &#x27;&quot; &#x27;].join(&#x27;&#x27;);
                    }
                }
                tblCellStyle = &#x27;style=&quot;max-width:&#x27; + this.datagrid.matchings[index].minWidth + &#x27;&quot;&#x27;;

                // call the type manipulate to manipulate the content of the cell
                if (!!type &amp;&amp; type === this.datagrid.types.THUMBNAILS) {
                    tblCellContent = this.datagrid.manipulateContent(tblCellContent, type, this.options.thumbnailFormat);
                    tblCellContent = &#x27;&lt;img alt=&quot;&#x27; + tblCellContent[constants.thumbAltKey] + &#x27;&quot; src=&quot;&#x27; + tblCellContent[constants.thumbSrcKey] + &#x27;&quot;/&gt;&#x27;;
                } else {
                    tblCellContent = this.datagrid.processContentFilter(key, tblCellContent, type, index);
                }

                if (!!editable) {
                    if (!!triggeredByAddRow) {
                        // differentiate for tab index
                        if (!!this.options.addRowTop) {
                            $cell = &#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &gt;&lt;span class=&quot;&#x27; + constants.editableClass + &#x27;&quot; style=&quot;display: none&quot;&gt;&#x27; + tblCellContent + &#x27;&lt;/span&gt;&lt;input type=&quot;text&quot; class=&quot;form-element editable-content&quot; tabindex=&quot;&#x27; + this.bottomTabIndex + &#x27;&quot; value=&quot;&#x27; + tblCellContent + &#x27;&quot;  &#x27; + validationAttr + &#x27;/&gt;&lt;/td&gt;&#x27;;
                            this.bottomTabIndex++;
                        } else {
                            $cell = &#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &gt;&lt;span class=&quot;&#x27; + constants.editableClass + &#x27;&quot; style=&quot;display: none&quot;&gt;&#x27; + tblCellContent + &#x27;&lt;/span&gt;&lt;input type=&quot;text&quot; class=&quot;form-element editable-content&quot; tabindex=&quot;&#x27; + this.topTabIndex + &#x27;&quot; value=&quot;&#x27; + tblCellContent + &#x27;&quot;  &#x27; + validationAttr + &#x27;/&gt;&lt;/td&gt;&#x27;;
                            this.topTabIndex++;
                        }
                    } else {
                        $cell = &#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &gt;&lt;span class=&quot;&#x27; + constants.editableClass + &#x27;&quot;&gt;&#x27; + tblCellContent + &#x27;&lt;/span&gt;&lt;input type=&quot;text&quot; class=&quot;form-element editable-content hidden&quot; value=&quot;&#x27; + tblCellContent + &#x27;&quot; tabindex=&quot;&#x27; + this.topTabIndex + &#x27;&quot; &#x27; + validationAttr + &#x27;/&gt;&lt;/td&gt;&#x27;;
                        this.topTabIndex++;

                    }
                    // if record has children and is first element in row add an icon
                } else if (index === 0 &amp;&amp; !!this.datagrid.options.childrenPropertyName) {
                    if (row[this.datagrid.options.childrenPropertyName] &gt; 0) {
                        $cell = &#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &#x27; + tblCellStyle + &#x27;&gt;&lt;div class=&quot;&#x27; + constants.slideDownClass + &#x27; &#x27; + constants.childrenIndentClass + &#x27;&quot;&gt;&lt;span class=&quot;&#x27; + constants.childrenSlideDownIcon + &#x27; toggle-icon&quot;&gt;&lt;/span&gt;&#x27; + tblCellContent + &#x27;&lt;/div&gt;&lt;/td&gt;&#x27;;
                    } else {
                        $cell = &#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &#x27; + tblCellStyle + &#x27;&gt;&lt;div class=&quot;&#x27; + constants.noChildrenClass + &#x27; &#x27; + constants.childrenIndentClass + &#x27;&quot;&gt;&#x27; + tblCellContent + &#x27;&lt;/div&gt;&lt;/td&gt;&#x27;;
                    }
                    $cell = this.sandbox.dom.createElement($cell);
                    $innerContainer = this.sandbox.dom.find(&#x27;.&#x27; + constants.childrenIndentClass, $cell);
                } else {
                    $cell = &#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &#x27; + tblCellStyle + &#x27;&gt;&#x27; + tblCellContent + &#x27;&lt;/td&gt;&#x27;;
                }
                $cell = this.sandbox.dom.createElement($cell);

                // add checkbox to first cell if configured
                if (index === 0 &amp;&amp; this.options.selectItem.inFirstCell === true) {
                    // dont display a checkbox if only leaves should get a checkbox and record has children
                    if (!(this.datagrid.options.onlySelectLeaves === true &amp;&amp; row[this.datagrid.options.childrenPropertyName] &gt; 0)) {
                        this.sandbox.dom.prepend($innerContainer || $cell, this.sandbox.util.template(templates.checkbox)({
                            id: &#x27;&#x27;,
                            checked: !!row.selected
                        }));
                    } else {
                        this.sandbox.dom.prepend($innerContainer || $cell, templates.checkboxPlaceholder);
                    }
                    // double the colspan because of the extra cell in the header
                    this.sandbox.dom.prop($cell, &#x27;colspan&#x27;, 2);
                }

                this.addIconsToCell($innerContainer || $cell, key, row);

                // push the html string to the global array
                this.tblColumns.push(this.sandbox.dom.outerHTML($cell));
            } else {
                this.tblRowAttributes += &#x27; data-&#x27; + key + &#x27;=&quot;&#x27; + value + &#x27;&quot;&#x27;;
            }
        },

        /**
         * Adds configured icons to a cell
         * @param $container {Object} the dom-object to append the icons to
         * @param column {String} the identifier of the column
         * @
         */
        addIconsToCell: function($container, column) {
            if (!!this.options.icons) {
                var i, length, $icon;

                for (i = -1, length = this.options.icons.length; ++i &lt; length;) {
                    if (column === this.options.icons[i].column) {
                        $icon = this.sandbox.dom.createElement(this.sandbox.util.template(templates.icon)({
                            icon: this.options.icons[i].icon,
                            align: this.options.icons[i].align || &#x27;left&#x27;
                        }));
                        this.sandbox.dom.attr($icon, &#x27;data-icon-index&#x27;, i);
                        this.sandbox.dom.append($container, $icon);
                    }
                }
            }
        },

        /**
         * Handles the click an an icon (calls the defined callback)
         * @param event
         */
        callIconCallback: function(event) {
            this.sandbox.dom.stopPropagation(event);
            var index = this.sandbox.dom.data(event.currentTarget, &#x27;iconIndex&#x27;),
                recordId = this.sandbox.dom.data(this.sandbox.dom.parents(event.currentTarget, &#x27;tr&#x27;), &#x27;id&#x27;);
            // call the callback
            if (!!this.options.icons[index] &amp;&amp; typeof this.options.icons[index].callback === &#x27;function&#x27;) {
                this.options.icons[index].callback(recordId);
            }
        },

        /**
         * Adds a row to the datagrid
         * @param row
         */
        addRecord: function(row) {
            var $row, $firstInputField, $checkbox, $parent;
            // check for other element types when implemented
            $row = this.sandbox.dom.$(this.prepareTableRow(row, true));

            // when unsaved new row exists - save it
            this.prepareSave();

            if (!!row.parent) {
                $parent = this.sandbox.dom.find(&#x27;tr[data-id=&quot;&#x27; + row.parent + &#x27;&quot;]&#x27;, this.$tableContainer);
            }

            // if record has a parent insert it after its parent else prepend or append row
            if (!!$parent) {
                this.insertChild($row, $parent, row.parent, false);
            } else if (!!this.options.addRowTop) {
                this.sandbox.dom.prepend(this.$table, $row);
            } else {
                this.sandbox.dom.append(this.$table, $row);
            }

            $firstInputField = this.sandbox.dom.find(&#x27;input[type=text]&#x27;, $row)[0];
            this.sandbox.dom.focus($firstInputField);

            if (!!this.options.editable) {
                this.lastFocusedRow = this.getInputValuesOfRow($row);
            }

            // if allchecked then disable top checkbox after adding new row
            if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) {
                $checkbox = this.sandbox.dom.find(&#x27;#&#x27; + constants.selectAllName, this.$tableContainer);
                if (this.sandbox.dom.hasClass($checkbox, constants.isSelectedClass)) {
                    this.sandbox.dom.prop($checkbox, &#x27;checked&#x27;, false);
                    this.sandbox.dom.removeClass($checkbox, constants.isSelectedClass);
                }
            }
        },

        /**
         * Inserts a child-element after a parent element and indents it
         * @param $child
         * @param $parent
         * @param parentId {Number|String} the id of the parent
         * @param hidden {Boolean} if true child gets hidden
         */
        insertChild: function ($child, $parent, parentId, hidden) {
            var $parentIcon, depth = this.sandbox.dom.data($parent, &#x27;depth&#x27;) || 0;
            depth = parseInt(depth, 10);
            $parentIcon = this.sandbox.dom.find(&#x27;.&#x27; + constants.slideDownClass + &#x27; .toggle-icon&#x27;, $parent);

            // make sure parent has children-loaded class
            this.sandbox.dom.addClass($parent, constants.childrenLoadedClass);

            this.sandbox.dom.attr($child, &#x27;data-parent&#x27;, parentId);
            this.sandbox.dom.data($child, &#x27;depth&#x27;, depth + 1);

            // indent the children-rows
            this.sandbox.dom.css(this.sandbox.dom.find(&#x27;.&#x27; + constants.childrenIndentClass, $child), {
                &#x27;margin-left&#x27;: (constants.childrenIndentPx * (depth + 1)) + &#x27;px&#x27;
            });

            if (hidden === true) {
                // change the icon of the parent
                this.sandbox.dom.removeClass($parentIcon, constants.childrenSlideUpIcon);
                this.sandbox.dom.prependClass($parentIcon, constants.childrenSlideDownIcon);
                this.sandbox.dom.hide($child);
            } else {
                // change the icon of the parent
                this.sandbox.dom.removeClass($parentIcon, constants.childrenSlideDownIcon);
                this.sandbox.dom.prependClass($parentIcon, constants.childrenSlideUpIcon);
            }

            this.sandbox.dom.after($parent, $child);
        },

        /**
         * Perparse to save new/changed data includes validation
         */
        prepareSave: function() {
            if (!!this.lastFocusedRow) {

                var $tr = this.sandbox.dom.find(&#x27;tr[data-dom-id=&#x27; + this.lastFocusedRow.domId + &#x27;]&#x27;, this.$tableContainer),
                    lastFocusedRowCurrentData = this.getInputValuesOfRow($tr),

                    data = {},
                    key,
                    url,
                    isValid = true,
                    valuesChanged = false,
                    isDataEmpty;

                data.id = lastFocusedRowCurrentData.id;

                // validate locally
                if (!!this.options.validation &amp;&amp; !this.sandbox.form.validate(&#x27;#&#x27; + this.datagrid.elId)) {
                    isValid = false;
                }

                isDataEmpty = this.isDataRowEmpty(lastFocusedRowCurrentData.fields);

                // do nothing when data is not valid or no data exists
                if (!!isValid &amp;&amp; !isDataEmpty) {

                    // check which values changed and remember these
                    for (key in lastFocusedRowCurrentData.fields) {
                        if (this.lastFocusedRow.fields.hasOwnProperty(key) &amp;&amp; this.lastFocusedRow.fields[key] !== lastFocusedRowCurrentData.fields[key]) {
                            data[key] = lastFocusedRowCurrentData.fields[key];
                            valuesChanged = true;
                        }
                    }

                    // trigger save action when data changed
                    if (!!valuesChanged || true) {
                        url = this.datagrid.getUrlWithoutParams();

                        // pass data to datagrid to save it
                        this.datagrid.saveGrid.call(this.datagrid, data, url,
                            this.saveSuccess.bind(this, this.lastFocusedRow.domId, $tr),
                            this.saveFail.bind(this, this.lastFocusedRow.domId, $tr),
                            this.options.addRowTop);

                        // reset last focused row after save
                        this.lastFocusedRow = null;

                    } else if (this.errorInRow.indexOf(this.lastFocusedRow.domId) !== -1) {
                        this.sandbox.logger.log(&quot;Error in table row!&quot;);

                    } else {
                        // nothing changed - reset immediately
                        this.sandbox.logger.log(&quot;No data changed!&quot;);
                        this.resetRowInputFields($tr);
                        this.unlockWidthsOfColumns(this.sandbox.dom.find(&#x27;table th&#x27;, this.$el));
                    }

                } else {
                    this.sandbox.logger.log(&quot;There seems to be some invalid or empty data!&quot;);
                }

            }
        },

        /**
         * Checks wether data is in row or not
         * @param data fields object
         */
        isDataRowEmpty: function(data) {
            var isEmpty = true, field;

            for (field in data) {
                if (data[field] !== &#x27;&#x27;) {
                    isEmpty = false;
                    break;
                }
            }

            return isEmpty;
        },

        /**
         * Callback for save success
         * @param $tr
         * @param domId
         * @param data
         */
        saveSuccess: function(domId, $tr, data) {
            // remove row from error list
            if (this.errorInRow.indexOf(domId) !== -1) {
                this.errorInRow.splice(this.errorInRow.indexOf(domId), 1);
            }

            this.resetRowInputFields($tr);
            this.unlockWidthsOfColumns(this.sandbox.dom.find(&#x27;table th&#x27;, this.$el));

            // set new returned data
            this.setDataForRow($tr[0], data);
        },

        /**
         * Callback for save fail
         * @param domId
         * @param $tr
         * @param jqXHR
         */
        saveFail: function(domId, $tr, jqXHR) {
            var message = JSON.parse(jqXHR.responseText);

            // remember row with error
            if (this.errorInRow.indexOf(domId) === -1) {
                this.errorInRow.push(domId);
            }
            // error in context with database constraints
            if (!!message.field) {
                this.showValidationError($tr, message.field);
            }
        },

        /**
         *  Hides input fields and displays new content for table row
         * @param $tr
         */
        resetRowInputFields: function($tr) {
            var $inputFields = this.sandbox.dom.find(&#x27;input[type=text]:not(.hidden)&#x27;, $tr),
                content, $span;

            this.sandbox.util.each($inputFields, function(index, $field) {

                // remove css class for server side validation error
                // TODO: remove this when server-validation validation type is implemented
                if (this.sandbox.dom.hasClass($field, constants.serverValidationError)) {
                    this.sandbox.dom.removeClass($field, constants.serverValidationError);
                }

                content = this.sandbox.dom.val(this.sandbox.dom.$($field));
                $span = this.sandbox.dom.prev($field, &#x27;.&#x27; + constants.editableClass);
                $span.text(content);

                this.sandbox.dom.addClass($field, &#x27;hidden&#x27;);
                this.sandbox.dom.show($span);

            }.bind(this));
        },

        /**
         * Resets the min-width of columns and
         * @param $th array of th elements
         */
        unlockWidthsOfColumns: function($th) {
            if (!!this.columnWidths) {
                this.sandbox.util.each($th, function(index, $el) {
                    // skip columns without data-attribute because the have min/max and normal widths by default
                    if (!!this.sandbox.dom.data($el, &#x27;attribute&#x27;)) {
                        this.sandbox.dom.css($el, &#x27;min-width&#x27;, this.columnWidths[index]);
                        this.sandbox.dom.css($el, &#x27;max-width&#x27;, &#x27;&#x27;);
                        this.sandbox.dom.css($el, &#x27;width&#x27;, &#x27;&#x27;);
                    }
                }.bind(this));
            }
        },

        /**
         * Makes the widths of columns fixed when the table is in edit mode
         * prevents changes in column width
         * @param $th array of th elements
         */
        lockWidthsOfColumns: function($th) {
            var width, minwidth;
            this.columnWidths = [];

            this.sandbox.dom.each($th, function(index, $el) {
                minwidth = this.sandbox.dom.css($el, &#x27;min-width&#x27;);
                this.columnWidths.push(minwidth);

                width = this.sandbox.dom.outerWidth($el);
                this.sandbox.dom.css($el, &#x27;min-width&#x27;, width);
                this.sandbox.dom.css($el, &#x27;max-width&#x27;, width);
                this.sandbox.dom.css($el, &#x27;width&#x27;, width);
            }.bind(this));
        },

        /**
         * Sets the data for a row
         * @param $tr dom row
         * @param data
         */
        setDataForRow: function($tr, data) {
            var editables, field, $input;

            // set id
            this.sandbox.dom.data($tr, &#x27;id&#x27;, data.id);
            this.sandbox.dom.attr($tr, &#x27;data-id&#x27;, data.id);

            this.sandbox.util.each(this.sandbox.dom.find(&#x27;td&#x27;, $tr), function(index, $el) {

                editables = this.sandbox.dom.find(&#x27;.&#x27; + constants.editableClass, $el);
                field = this.sandbox.dom.data($el, &#x27;field&#x27;);
                $input = this.sandbox.dom.find(&#x27;input[type=text]&#x27;, $el);

                if (!!field) {
                    if (!!editables &amp;&amp; editables.length === 1) { // set values in spans
                        this.sandbox.dom.html(editables[0], data[field]);
                        this.sandbox.dom.val($input, data[field]);
                    } else { // set values in td
                        this.sandbox.dom.html($el, data[field]);
                    }
                }

            }.bind(this));
        },

        /**
         * Sets the validation error class for a dom element
         * @param $domElement
         * @param field name of field which caused the error
         */
        showValidationError: function($domElement, field) {
            var $td = this.sandbox.dom.find(&#x27;td[data-field=&#x27; + field + &#x27;]&#x27;, $domElement)[0],
                $input = this.sandbox.dom.find(&#x27;input&#x27;, $td)[0];

            if (this.sandbox.dom.hasClass($td, &#x27;husky-validate-success&#x27;)) {
                this.sandbox.dom.removeClass($td, &#x27;husky-validate-success&#x27;);
            }

            this.sandbox.dom.addClass($td, &#x27;husky-validate-error&#x27;);

            // add class for serverside validation error
            // TODO remove this when correct validation type is implmented
            if (!this.sandbox.dom.hasClass($input, constants.serverValidationError)) {
                this.sandbox.dom.addClass($input, constants.serverValidationError);
            }
        },

        /**
         * Returns an object with the current values of the inputfields, id and domId
         * @param $tr table row
         * @returns {{domId: *, id: *, fields: Array}}
         */
        getInputValuesOfRow: function($tr) {
            var id = this.sandbox.dom.data($tr, &#x27;id&#x27;),
                domId = this.sandbox.dom.data($tr, &#x27;dom-id&#x27;),
                $inputs = this.sandbox.dom.find(&#x27;input[type=text]&#x27;, $tr),
                fields = [], field, $td;

            this.sandbox.dom.each($inputs, function(index, $input) {
                $td = this.sandbox.dom.parent($input, &#x27;td&#x27;);
                field = this.sandbox.dom.data($td, &#x27;field&#x27;);

                fields[field] = $input.value;

            }.bind(this));
            return {
                domId: domId,
                id: id,
                fields: fields
            };

        },

        /**
         * Prepares for removing a row
         * Raises the husky.datagrid.record.remove-click event when auto remove handling is not set to true
         * @param event
         */
        prepareRemoveRow: function(event) {
            this.sandbox.dom.stopPropagation(event);
            this.removeRecord(event);
        },

        /**
         * Removes a row from the datagrid
         * @param event
         */
        removeRecord: function(event) {
            var $element, $tblRow, id, $editableElements, $checkboxes;

            if (typeof event === &#x27;object&#x27;) {
                $element = this.sandbox.dom.$(event.currentTarget);
                $tblRow = this.sandbox.dom.closest($element, &#x27;tr&#x27;)[0];
                id = this.sandbox.dom.data($tblRow, &#x27;id&#x27;);
            } else {
                id = event;
                $tblRow = this.sandbox.dom.find(&#x27;tr[data-id=&quot;&#x27; + id + &#x27;&quot;]&#x27;)[0];
            }

            // remove row elements from validation
            if (!!this.options.validation) {
                $editableElements = this.sandbox.dom.find(&#x27;.&#x27; + constants.editableClass, $tblRow);
                this.sandbox.util.each($editableElements, function(index, $element) {
                    this.sandbox.form.removeField(&#x27;#&#x27; + this.datagrid.elId, $element);
                }.bind(this));
            }

            if (!!id) {
                this.datagrid.removeRecord.call(this.datagrid, id);
            }
            this.sandbox.dom.remove($tblRow);

            // when last table row was removed, uncheck thead checkbox if exists
            $checkboxes = this.sandbox.dom.find(&#x27;input[type=checkbox]&#x27;, this.$el);
            if ($checkboxes.length === 1) {
                this.sandbox.dom.removeClass(constants.isSelectedClass, $checkboxes[0]);
                this.sandbox.dom.prop($checkboxes[0], &#x27;checked&#x27;, false);
            }

        },

        /**
         * Gets automatically executed on window resize
         * responsible for the responsiveness
         */
        onResize: function() {
            var finalWidth,
                contentPaddings = 0,
                tableWidth = this.sandbox.dom.width(this.$table),
                tableOffset = this.sandbox.dom.offset(this.$table),
                contentWidth = this.sandbox.dom.width(content),
                windowWidth = this.sandbox.dom.width(this.sandbox.dom.window),
                overlaps = false,
                originalMaxWidth = contentWidth;

            tableOffset.right = tableOffset.left + tableWidth;

            // if table is greater than max content width
            if (tableWidth &gt; originalMaxWidth - contentPaddings &amp;&amp; contentWidth &lt; windowWidth - tableOffset.left) {
                // adding this class, forces table cells to shorten long words
                this.sandbox.dom.addClass(this.$el, constants.oversizedClass);
                overlaps = true;
                // reset table width and offset
                tableWidth = this.sandbox.dom.width(this.$table);
                tableOffset.right = tableOffset.left + tableWidth;
            }

            // tablecontainer should have width of table in normal cases
            finalWidth = tableWidth;

            // if table &gt; window-size set width to available space
            if (tableOffset.right + this.contentMarginRight &gt; windowWidth) {
                finalWidth = windowWidth - tableOffset.left;
            } else {
                // set scroll position back
                this.sandbox.dom.scrollLeft(this.$el, 0);
            }

            // width is not allowed to be smaller than the width of content
            if (finalWidth &lt; contentWidth) {
                finalWidth = contentWidth;
            }

            // now set width
            this.sandbox.dom.width(this.$el, finalWidth);

            // check scrollwidth and add class
            if (this.sandbox.dom.get(this.$tableContainer, 0).scrollWidth &gt; finalWidth) {
                this.sandbox.dom.addClass(this.$tableContainer, constants.overflowClass);

                // if overflown and in full width mode reduce list-width
                if (this.options.fullWidth === true) {
                    finalWidth = finalWidth - constants.overflowIconSpacing;
                    this.sandbox.dom.width(this.$el, finalWidth);
                }

            } else {
                this.sandbox.dom.removeClass(this.$tableContainer, constants.overflowClass);
            }
        },

        /**
         * Selectes or deselects the clicked item
         * @param event
         */
        selectItem: function(event) {
            this.sandbox.dom.stopPropagation(event);

            var $element, itemId, parentTr;
            $element = this.sandbox.dom.$(event.currentTarget);

            if (!this.sandbox.dom.is($element, &#x27;input&#x27;)) {
                $element = this.sandbox.dom.find(&#x27;input&#x27;, this.sandbox.dom.parent($element));
            }

            parentTr = this.sandbox.dom.parents($element, &#x27;tr&#x27;);
            itemId = this.sandbox.dom.data(parentTr, &#x27;id&#x27;);

            if (this.sandbox.dom.attr($element, &#x27;type&#x27;) === &#x27;checkbox&#x27;) {
                if (this.sandbox.dom.prop($element, &#x27;checked&#x27;) === false) {
                    this.sandbox.dom.removeClass($element, constants.isSelectedClass);
                    this.sandbox.dom.prop($element, &#x27;checked&#x27;, false);

                    // uncheck &#x27;Select All&#x27;-checkbox
                    this.sandbox.dom.prop(
                        this.sandbox.dom.find(&#x27;#&#x27; + constants.selectAllName, this.$tableContainer),
                        &#x27;checked&#x27;, false
                    );

                    this.datagrid.setItemUnselected.call(this.datagrid, itemId);
                } else {
                    this.sandbox.dom.addClass($element, constants.isSelectedClass);
                    this.sandbox.dom.prop($element, &#x27;checked&#x27;, true);
                    if (!!itemId) {
                        this.datagrid.setItemSelected.call(this.datagrid, itemId);
                    }
                }

            } else if (this.sandbox.dom.attr($element, &#x27;type&#x27;) === &#x27;radio&#x27;) {

                this.datagrid.deselectAllItems.call(this.datagrid);

                this.sandbox.dom.removeClass(
                    this.sandbox.dom.find(&#x27;tr input[type=&quot;radio&quot;]&#x27;, this.$tableContainer), constants.isSelectedClass);
                this.sandbox.dom.prop(
                    this.sandbox.dom.find(&#x27;tr input[type=&quot;radio&quot;]&#x27;, this.$tableContainer), &#x27;checked&#x27;, false);

                this.sandbox.dom.addClass($element, constants.isSelectedClass);
                this.sandbox.dom.prop($element, &#x27;checked&#x27;, true);

                if (!!itemId) {
                    this.datagrid.setItemSelected.call(this.datagrid, itemId);
                }
            }

        },

        /**
         * Shows input and hides span
         * @param event
         */
        editCellValues: function(event) {
            var $target = event.currentTarget,
                $input = this.sandbox.dom.next($target, &#x27;input&#x27;);

            this.lockWidthsOfColumns(this.sandbox.dom.find(&#x27;table th&#x27;, this.$tableContainer));

            this.sandbox.dom.hide($target);
            this.sandbox.dom.removeClass($input, &#x27;hidden&#x27;);
            this.sandbox.dom.select($input[0]);
        },

        /**
         * Put focus on table row and remember values
         */
        focusOnRow: function(event) {
            var $tr = event.currentTarget,
                domId = this.sandbox.dom.data($tr, &#x27;dom-id&#x27;);

            this.sandbox.dom.stopPropagation(event);
            this.sandbox.logger.log(&quot;focus on row&quot;, domId);

            if (!!this.lastFocusedRow &amp;&amp; this.lastFocusedRow.domId !== domId) { // new focus
                this.prepareSave();
                this.lastFocusedRow = this.getInputValuesOfRow($tr);
                this.sandbox.logger.log(&quot;focused &quot; + this.lastFocusedRow.domId + &quot; now!&quot;);
            } else if (!this.lastFocusedRow) { // first focus
                this.lastFocusedRow = this.getInputValuesOfRow($tr);
                this.sandbox.logger.log(&quot;focused &quot; + this.lastFocusedRow.domId + &quot; now!&quot;);
            }
        },

        /**
         * Selects or deselect all available items of the list
         * @param event
         */
        selectAllItems: function(event) {
            this.sandbox.dom.stopPropagation(event);

            var $headCheckbox = this.sandbox.dom.find(&#x27;th input[type=&quot;checkbox&quot;]&#x27;, this.$tableContainer)[0],
                $checkboxes = this.sandbox.dom.find(&#x27;input[type=&quot;checkbox&quot;]:visible&#x27;, this.$tableContainer);

            if (this.sandbox.dom.prop($headCheckbox, &#x27;checked&#x27;) === false) {
                this.sandbox.dom.prop($checkboxes, &#x27;checked&#x27;, false);
                this.sandbox.dom.removeClass($checkboxes, constants.isSelectedClass);
                this.datagrid.deselectAllItems.call(this.datagrid);
            } else {
                this.sandbox.dom.prop($checkboxes, &#x27;checked&#x27;, true);
                this.sandbox.dom.addClass($checkboxes, constants.isSelectedClass);
                this.datagrid.selectAllItems.call(this.datagrid);
            }
        },

        /**
         * Takes a record id and returns true if the record has children
         * @param id {Number|String} the id of the record
         * @returns {boolean} true if has children, false if not
         */
        recordHasChildren: function(id) {
            for (var i = -1, length = this.data.embedded.length; ++i &lt; length;) {
                if (this.data.embedded[i].id === id) {
                    return this.data.embedded[i][this.datagrid.options.childrenPropertyName] &gt; 0;
                }
            }
            return false;
        },

        /**
         * Handles the click on a table row if elements in the grid have children
         *
         * @param event
         */
        prepareChildrenLoad: function(event) {
            this.sandbox.dom.stopPropagation(event);
            var recordId = this.sandbox.dom.data(event.currentTarget, &#x27;id&#x27;);

            // only load children if they are not already loaded
            if (!this.sandbox.dom.hasClass(event.currentTarget, constants.childrenLoadedClass)) {
                if (!!recordId &amp;&amp; this.recordHasChildren(recordId)) {
                    this.sandbox.dom.addClass(event.currentTarget, constants.childrenLoadedClass);
                    this.datagrid.loadChildren.call(this.datagrid, recordId);
                }
            } else {
                this.toggleChildren(event.currentTarget, recordId);
            }
        },

        /**
         * Toggles the already loaded children of a parent element
         * @param $parent
         * @param parentId
         */
        toggleChildren: function($parent, parentId) {
            var $children = this.sandbox.dom.find(&#x27;tr[data-parent=&quot;&#x27;+ parentId +&#x27;&quot;]&#x27;, this.$tableContainer);

            if (this.sandbox.dom.is($children, &#x27;:visible&#x27;)) {
                this.hideChildren($parent, parentId);
            } else {
                this.showChildren($parent, parentId);
            }
        },

        /**
         * Opens all parents of a data-record and because of that makes sure that the data-record is visible in the table
         * @param id {Number|String} the id of the data-record
         */
        openAllParents: function(id) {
            var $child = this.sandbox.dom.find(&#x27;tr[data-id=&quot;&#x27;+ id +&#x27;&quot;]&#x27;, this.$tableContainer),
                parentId = this.sandbox.dom.data($child, &#x27;parent&#x27;),
                $parent = this.sandbox.dom.find(&#x27;tr[data-id=&quot;&#x27;+ parentId +&#x27;&quot;]&#x27;, this.$tableContainer);
            if (!!parentId &amp;&amp; !!$parent) {
                if (!!this.sandbox.dom.data($parent, &#x27;parent&#x27;)) {
                    this.openAllParents(parentId);
                }
                this.showChildren($parent, parentId);
            }
        },

        /**
         * Shows the first-level of children of a record
         * @param $parent
         * @param parentId
         */
        showChildren: function($parent, parentId) {
            var $children = this.sandbox.dom.find(&#x27;tr[data-parent=&quot;&#x27;+ parentId +&#x27;&quot;]&#x27;, this.$tableContainer),
                $parentIcon = this.sandbox.dom.find(&#x27;.&#x27; + constants.slideDownClass + &#x27; .toggle-icon&#x27;, $parent);

            this.sandbox.dom.removeClass($parentIcon, constants.childrenSlideDownIcon);
            this.sandbox.dom.prependClass($parentIcon, constants.childrenSlideUpIcon);
            this.sandbox.dom.show($children);
        },

        /**
         * Recursivly hides all children of a given parent (with nested ones)
         * @param $parent
         * @param parentId
         */
        hideChildren: function($parent, parentId) {
            var $children = this.sandbox.dom.find(&#x27;tr[data-parent=&quot;&#x27;+ parentId +&#x27;&quot;]&#x27;, this.$tableContainer),
                $parentIcon = this.sandbox.dom.find(&#x27;.&#x27; + constants.slideDownClass + &#x27; .toggle-icon&#x27;, $parent);

            this.sandbox.util.foreach($children, function($child) {
                if (this.sandbox.dom.hasClass($child, constants.childrenLoadedClass)) {
                    this.hideChildren($child, this.sandbox.dom.data($child, &#x27;id&#x27;));
                }
            }.bind(this));
            this.sandbox.dom.removeClass($parentIcon, constants.childrenSlideUpIcon);
            this.sandbox.dom.prependClass($parentIcon, constants.childrenSlideDownIcon);
            this.sandbox.dom.hide($children);
        },

        /**
         * Handles the click on a sortable column title
         *
         * Creates the function parameters need for sorting
         * and delegates the sorting itself to the datagrid
         * @param event {Object} the event object
         */
        prepareSort: function(event) {
            var $element = event.currentTarget,
                $span = this.sandbox.dom.children($element, &#x27;span&#x27;)[0],
                attribute = this.sandbox.dom.data($element, &#x27;attribute&#x27;),
                direction = this.sandbox.dom.hasClass($span, constants.ascClass) ? &#x27;desc&#x27; : &#x27;asc&#x27;,
                $loaderContainer = this.sandbox.dom.createElement(&#x27;&lt;span class=&quot;&#x27;+ constants.sortLoaderClass +&#x27;&quot;/&gt;&#x27;);

            this.sandbox.dom.stopPropagation(event);

            // start loader beneath th
            this.sandbox.dom.removeClass($span);
            this.sandbox.dom.append($span, $loaderContainer);
            this.sandbox.start([
                {
                    name: &#x27;loader@husky&#x27;,
                    options: {
                        el: $loaderContainer,
                        size: &#x27;10px&#x27;,
                        color: &#x27;#999999&#x27;
                    }
                }
            ]);

            // delegate sorting to datagrid
            this.datagrid.sortGrid.call(this.datagrid, attribute, direction);
        }
    };
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
